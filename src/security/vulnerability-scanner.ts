/**
 * Security Testing and Vulnerability Management System
 * Automated security scanning, vulnerability assessment, and remediation tracking
 */

import { EventEmitter } from 'events';
import { monitoringService } from '../monitoring/monitoring-service';
import { soc2ComplianceService } from '../compliance/soc2-controls';
import { encryptionService } from './encryption-service';

export interface SecurityVulnerability {
  id: string;
  title: string;
  description: string;
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  category:
    | 'injection'
    | 'authentication'
    | 'sensitive_data'
    | 'xml'
    | 'broken_access'
    | 'security_misconfiguration'
    | 'xss'
    | 'insecure_deserialization'
    | 'components'
    | 'logging';
  cweId?: string; // Common Weakness Enumeration ID
  cvssScore?: number; // Common Vulnerability Scoring System
  location: {
    file?: string;
    line?: number;
    endpoint?: string;
    parameter?: string;
  };
  discoveredAt: Date;
  status: 'open' | 'in_progress' | 'fixed' | 'accepted_risk' | 'false_positive';
  assignee?: string;
  dueDate?: Date;
  fixedAt?: Date;
  evidence: string[];
  recommendation: string;
  references: string[];
}

export interface SecurityScanResult {
  scanId: string;
  scanType: 'sast' | 'dast' | 'dependency' | 'configuration' | 'manual';
  startTime: Date;
  endTime: Date;
  status: 'running' | 'completed' | 'failed';
  vulnerabilities: SecurityVulnerability[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  };
  coverage: {
    filesScanned?: number;
    endpointsScanned?: number;
    dependenciesScanned?: number;
  };
}

export interface PenetrationTestResult {
  testId: string;
  tester: string;
  startDate: Date;
  endDate: Date;
  scope: string[];
  methodology: string;
  findings: SecurityVulnerability[];
  executiveSummary: string;
  technicalSummary: string;
  recommendations: string[];
  riskRating: 'low' | 'medium' | 'high' | 'critical';
}

export class VulnerabilityManagementService extends EventEmitter {
  private vulnerabilities: Map<string, SecurityVulnerability>;
  private scanResults: Map<string, SecurityScanResult>;
  private penTestResults: Map<string, PenetrationTestResult>;
  private isScanning: boolean;

  constructor() {
    super();
    this.vulnerabilities = new Map();
    this.scanResults = new Map();
    this.penTestResults = new Map();
    this.isScanning = false;

    this.initializeSecurityScanning();
  }

  /**
   * Initialize security scanning schedules
   */
  private initializeSecurityScanning(): void {
    // Run SAST scan daily at 2 AM
    this.scheduleRecurringScan('sast', '0 2 * * *');

    // Run dependency scan daily at 3 AM
    this.scheduleRecurringScan('dependency', '0 3 * * *');

    // Run configuration scan weekly on Sundays at 4 AM
    this.scheduleRecurringScan('configuration', '0 4 * * 0');

    console.log('Security scanning schedules initialized');
  }

  /**
   * Schedule recurring security scans
   */
  private scheduleRecurringScan(
    scanType: SecurityScanResult['scanType'],
    cronExpression: string
  ): void {
    // In a real implementation, this would use a cron job scheduler
    // For now, we'll simulate with a simple interval
    const intervalMs =
      scanType === 'sast' || scanType === 'dependency'
        ? 24 * 60 * 60 * 1000
        : 7 * 24 * 60 * 60 * 1000;

    setInterval(async () => {
      if (!this.isScanning) {
        await this.runSecurityScan(scanType);
      }
    }, intervalMs);
  }

  /**
   * Run a comprehensive security scan
   */
  async runSecurityScan(
    scanType: SecurityScanResult['scanType']
  ): Promise<string> {
    const scanId = `${scanType}_${Date.now()}`;
    const scanResult: SecurityScanResult = {
      scanId,
      scanType,
      startTime: new Date(),
      endTime: new Date(),
      status: 'running',
      vulnerabilities: [],
      summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0, info: 0 },
      coverage: {},
    };

    this.scanResults.set(scanId, scanResult);
    this.isScanning = true;

    try {
      console.log(`Starting ${scanType} security scan: ${scanId}`);
      this.emit('scanStarted', { scanId, scanType });

      let vulnerabilities: SecurityVulnerability[] = [];

      switch (scanType) {
        case 'sast':
          vulnerabilities = await this.runStaticAnalysisScan();
          scanResult.coverage.filesScanned = 150; // Simulated
          break;
        case 'dast':
          vulnerabilities = await this.runDynamicAnalysisScan();
          scanResult.coverage.endpointsScanned = 25;
          break;
        case 'dependency':
          vulnerabilities = await this.runDependencyScan();
          scanResult.coverage.dependenciesScanned = 45;
          break;
        case 'configuration':
          vulnerabilities = await this.runConfigurationScan();
          break;
        case 'manual':
          vulnerabilities = await this.runManualSecurityReview();
          break;
      }

      // Store vulnerabilities and update summary
      vulnerabilities.forEach(vuln => {
        this.vulnerabilities.set(vuln.id, vuln);
        scanResult.vulnerabilities.push(vuln);
        scanResult.summary[vuln.severity]++;
        scanResult.summary.total++;
      });

      scanResult.status = 'completed';
      scanResult.endTime = new Date();

      // Record metrics
      monitoringService.recordMetric('security_scans_completed', 1, 'count', {
        scanType,
        vulnerabilitiesFound: scanResult.summary.total.toString(),
      });

      monitoringService.recordMetric(
        'security_vulnerabilities_found',
        scanResult.summary.total,
        'count',
        { scanType, severity: 'total' }
      );

      // Log audit event
      await soc2ComplianceService.logAuditEvent({
        action: 'security_scan_completed',
        resource: scanId,
        outcome: 'success',
        ipAddress: 'system',
        userAgent: 'vulnerability-scanner',
        details: { scanResult },
        riskLevel:
          scanResult.summary.critical > 0
            ? 'critical'
            : scanResult.summary.high > 0
              ? 'high'
              : 'medium',
      });

      // Create incidents for critical/high vulnerabilities
      for (const vuln of vulnerabilities) {
        if (vuln.severity === 'critical' || vuln.severity === 'high') {
          await this.createSecurityIncident(vuln);
        }
      }

      console.log(
        `Security scan ${scanId} completed: ${scanResult.summary.total} vulnerabilities found`
      );
      this.emit('scanCompleted', { scanId, scanResult });

      return scanId;
    } catch (error) {
      scanResult.status = 'failed';
      scanResult.endTime = new Date();

      console.error(`Security scan ${scanId} failed:`, error);
      this.emit('scanFailed', { scanId, error });

      throw error;
    } finally {
      this.isScanning = false;
    }
  }

  /**
   * Run Static Application Security Testing (SAST)
   */
  private async runStaticAnalysisScan(): Promise<SecurityVulnerability[]> {
    console.log('Running static analysis security scan...');
    await new Promise(resolve => setTimeout(resolve, 5000)); // Simulate scan time

    // Simulate finding vulnerabilities in code
    const vulnerabilities: SecurityVulnerability[] = [];

    // Simulate SQL injection vulnerability
    if (Math.random() < 0.3) {
      vulnerabilities.push({
        id: `vuln_sast_${Date.now()}_1`,
        title: 'SQL Injection Vulnerability',
        description: 'Potentially unsafe SQL query construction detected',
        severity: 'high',
        category: 'injection',
        cweId: 'CWE-89',
        cvssScore: 7.5,
        location: {
          file: 'src/services/database.ts',
          line: 245,
        },
        discoveredAt: new Date(),
        status: 'open',
        evidence: ['Direct string concatenation in SQL query'],
        recommendation:
          'Use parameterized queries or ORM methods to prevent SQL injection',
        references: ['https://owasp.org/www-community/attacks/SQL_Injection'],
      });
    }

    // Simulate XSS vulnerability
    if (Math.random() < 0.4) {
      vulnerabilities.push({
        id: `vuln_sast_${Date.now()}_2`,
        title: 'Cross-Site Scripting (XSS) Vulnerability',
        description: 'User input is not properly sanitized before output',
        severity: 'medium',
        category: 'xss',
        cweId: 'CWE-79',
        cvssScore: 6.1,
        location: {
          file: 'src/api/routes/messages.ts',
          line: 123,
        },
        discoveredAt: new Date(),
        status: 'open',
        evidence: ['Unescaped user input in response'],
        recommendation: 'Implement proper input validation and output encoding',
        references: ['https://owasp.org/www-community/attacks/xss/'],
      });
    }

    return vulnerabilities;
  }

  /**
   * Run Dynamic Application Security Testing (DAST)
   */
  private async runDynamicAnalysisScan(): Promise<SecurityVulnerability[]> {
    console.log('Running dynamic analysis security scan...');
    await new Promise(resolve => setTimeout(resolve, 8000)); // Simulate scan time

    const vulnerabilities: SecurityVulnerability[] = [];

    // Simulate authentication bypass
    if (Math.random() < 0.2) {
      vulnerabilities.push({
        id: `vuln_dast_${Date.now()}_1`,
        title: 'Authentication Bypass Vulnerability',
        description: 'Endpoint accessible without proper authentication',
        severity: 'critical',
        category: 'authentication',
        cweId: 'CWE-287',
        cvssScore: 9.8,
        location: {
          endpoint: '/api/v1/admin/users',
        },
        discoveredAt: new Date(),
        status: 'open',
        evidence: ['HTTP 200 response without authentication header'],
        recommendation:
          'Implement proper authentication middleware for admin endpoints',
        references: [
          'https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication',
        ],
      });
    }

    return vulnerabilities;
  }

  /**
   * Run dependency vulnerability scan
   */
  private async runDependencyScan(): Promise<SecurityVulnerability[]> {
    console.log('Running dependency vulnerability scan...');
    await new Promise(resolve => setTimeout(resolve, 3000));

    const vulnerabilities: SecurityVulnerability[] = [];

    // Simulate vulnerable dependency
    if (Math.random() < 0.6) {
      vulnerabilities.push({
        id: `vuln_dep_${Date.now()}_1`,
        title: 'Vulnerable Dependency: express@4.17.1',
        description:
          'Known security vulnerability in Express.js version 4.17.1',
        severity: 'medium',
        category: 'components',
        cweId: 'CWE-1035',
        cvssScore: 5.3,
        location: {
          file: 'package.json',
        },
        discoveredAt: new Date(),
        status: 'open',
        evidence: ['CVE-2022-24999 affects Express.js < 4.18.2'],
        recommendation: 'Update Express.js to version 4.18.2 or later',
        references: ['https://nvd.nist.gov/vuln/detail/CVE-2022-24999'],
      });
    }

    return vulnerabilities;
  }

  /**
   * Run configuration security scan
   */
  private async runConfigurationScan(): Promise<SecurityVulnerability[]> {
    console.log('Running configuration security scan...');
    await new Promise(resolve => setTimeout(resolve, 2000));

    const vulnerabilities: SecurityVulnerability[] = [];

    // Check security headers
    if (Math.random() < 0.5) {
      vulnerabilities.push({
        id: `vuln_config_${Date.now()}_1`,
        title: 'Missing Security Headers',
        description: 'Application is missing important security headers',
        severity: 'low',
        category: 'security_misconfiguration',
        cweId: 'CWE-16',
        location: {
          endpoint: 'Global HTTP headers',
        },
        discoveredAt: new Date(),
        status: 'open',
        evidence: [
          'Missing X-Frame-Options header',
          'Missing X-Content-Type-Options header',
        ],
        recommendation:
          'Configure security headers using helmet.js or similar middleware',
        references: ['https://owasp.org/www-project-secure-headers/'],
      });
    }

    return vulnerabilities;
  }

  /**
   * Run manual security review
   */
  private async runManualSecurityReview(): Promise<SecurityVulnerability[]> {
    console.log('Running manual security review...');
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Manual reviews would be conducted by security experts
    return [];
  }

  /**
   * Create security incident for critical vulnerabilities
   */
  private async createSecurityIncident(
    vulnerability: SecurityVulnerability
  ): Promise<void> {
    await soc2ComplianceService.createIncident({
      severity: vulnerability.severity === 'critical' ? 'critical' : 'high',
      category: 'security',
      description: `Security vulnerability detected: ${vulnerability.title}`,
      impact: `${vulnerability.severity} severity vulnerability in ${vulnerability.location.file || vulnerability.location.endpoint}`,
      status: 'open',
      assignee: 'security-team',
      preventiveActions: [vulnerability.recommendation],
    });
  }

  /**
   * Update vulnerability status
   */
  async updateVulnerabilityStatus(
    vulnerabilityId: string,
    status: SecurityVulnerability['status'],
    assignee?: string,
    notes?: string
  ): Promise<void> {
    const vulnerability = this.vulnerabilities.get(vulnerabilityId);
    if (!vulnerability) {
      throw new Error(`Vulnerability ${vulnerabilityId} not found`);
    }

    const oldStatus = vulnerability.status;
    vulnerability.status = status;

    if (assignee) {
      vulnerability.assignee = assignee;
    }

    if (status === 'fixed') {
      vulnerability.fixedAt = new Date();
    }

    // Record metrics
    monitoringService.recordMetric('vulnerability_status_changes', 1, 'count', {
      from: oldStatus,
      to: status,
      severity: vulnerability.severity,
      category: vulnerability.category,
    });

    // Log audit event
    await soc2ComplianceService.logAuditEvent({
      action: 'vulnerability_status_updated',
      resource: vulnerabilityId,
      outcome: 'success',
      ipAddress: 'system',
      userAgent: 'vulnerability-management',
      details: { oldStatus, newStatus: status, assignee, notes },
      riskLevel:
        vulnerability.severity === 'critical' ||
        vulnerability.severity === 'high'
          ? 'high'
          : 'medium',
    });

    this.emit('vulnerabilityUpdated', {
      vulnerabilityId,
      vulnerability,
      oldStatus,
      newStatus: status,
    });
  }

  /**
   * Run penetration test
   */
  async runPenetrationTest(
    scope: string[],
    tester: string,
    methodology: string = 'OWASP Testing Guide'
  ): Promise<string> {
    const testId = `pentest_${Date.now()}`;
    const startDate = new Date();

    console.log(`Starting penetration test: ${testId}`);
    this.emit('penTestStarted', { testId, scope, tester });

    // Simulate penetration testing time
    await new Promise(resolve => setTimeout(resolve, 10000));

    const findings: SecurityVulnerability[] = [];

    // Simulate penetration test findings
    if (Math.random() < 0.7) {
      findings.push({
        id: `vuln_pentest_${Date.now()}_1`,
        title: 'Business Logic Flaw in Authentication',
        description:
          'Penetration testing revealed authentication bypass through session manipulation',
        severity: 'high',
        category: 'authentication',
        cweId: 'CWE-384',
        cvssScore: 8.1,
        location: {
          endpoint: '/api/v1/auth/login',
        },
        discoveredAt: new Date(),
        status: 'open',
        evidence: [
          'Session fixation attack successful',
          'JWT token manipulation allowed',
        ],
        recommendation:
          'Implement proper session management and JWT validation',
        references: [
          'https://owasp.org/www-community/attacks/Session_fixation',
        ],
      });
    }

    // Store findings
    findings.forEach(finding => {
      this.vulnerabilities.set(finding.id, finding);
    });

    const riskRating: PenetrationTestResult['riskRating'] = findings.some(
      f => f.severity === 'critical'
    )
      ? 'critical'
      : findings.some(f => f.severity === 'high')
        ? 'high'
        : findings.some(f => f.severity === 'medium')
          ? 'medium'
          : 'low';

    const penTestResult: PenetrationTestResult = {
      testId,
      tester,
      startDate,
      endDate: new Date(),
      scope,
      methodology,
      findings,
      executiveSummary: `Penetration test completed with ${findings.length} findings. Risk rating: ${riskRating}`,
      technicalSummary:
        'Comprehensive security assessment conducted using industry-standard methodologies.',
      recommendations: findings.map(f => f.recommendation),
      riskRating,
    };

    this.penTestResults.set(testId, penTestResult);

    // Record metrics
    monitoringService.recordMetric('penetration_tests_completed', 1, 'count', {
      tester,
      riskRating,
      findingsCount: findings.length.toString(),
    });

    console.log(
      `Penetration test ${testId} completed with ${findings.length} findings`
    );
    this.emit('penTestCompleted', { testId, result: penTestResult });

    return testId;
  }

  /**
   * Generate security report
   */
  generateSecurityReport(): {
    summary: any;
    vulnerabilities: SecurityVulnerability[];
    scanHistory: SecurityScanResult[];
    penTestHistory: PenetrationTestResult[];
    riskMetrics: any;
  } {
    const vulnerabilities = Array.from(this.vulnerabilities.values());
    const scanHistory = Array.from(this.scanResults.values()).slice(-10);
    const penTestHistory = Array.from(this.penTestResults.values()).slice(-5);

    const summary = {
      totalVulnerabilities: vulnerabilities.length,
      openVulnerabilities: vulnerabilities.filter(v => v.status === 'open')
        .length,
      criticalVulnerabilities: vulnerabilities.filter(
        v => v.severity === 'critical'
      ).length,
      highVulnerabilities: vulnerabilities.filter(v => v.severity === 'high')
        .length,
      mediumVulnerabilities: vulnerabilities.filter(
        v => v.severity === 'medium'
      ).length,
      lowVulnerabilities: vulnerabilities.filter(v => v.severity === 'low')
        .length,
      fixedVulnerabilities: vulnerabilities.filter(v => v.status === 'fixed')
        .length,
      lastScanDate: scanHistory[scanHistory.length - 1]?.endTime,
      lastPenTestDate: penTestHistory[penTestHistory.length - 1]?.endDate,
    };

    const riskMetrics = {
      securityScore: this.calculateSecurityScore(vulnerabilities),
      trendDirection: this.calculateTrend(scanHistory),
      complianceStatus:
        summary.criticalVulnerabilities === 0 &&
        summary.highVulnerabilities < 5,
      remediationRate:
        summary.fixedVulnerabilities /
        Math.max(summary.totalVulnerabilities, 1),
    };

    return {
      summary,
      vulnerabilities,
      scanHistory,
      penTestHistory,
      riskMetrics,
    };
  }

  /**
   * Calculate security score (0-100)
   */
  private calculateSecurityScore(
    vulnerabilities: SecurityVulnerability[]
  ): number {
    if (vulnerabilities.length === 0) return 100;

    const weights = { critical: 10, high: 5, medium: 2, low: 1, info: 0.5 };
    const openVulns = vulnerabilities.filter(v => v.status === 'open');

    const totalRisk = openVulns.reduce(
      (sum, v) => sum + weights[v.severity],
      0
    );
    const maxRisk = vulnerabilities.length * weights.critical;

    return Math.max(0, Math.round(100 - (totalRisk / maxRisk) * 100));
  }

  /**
   * Calculate security trend
   */
  private calculateTrend(
    scanHistory: SecurityScanResult[]
  ): 'improving' | 'stable' | 'declining' {
    if (scanHistory.length < 2) return 'stable';

    const recent = scanHistory.slice(-3);
    const avgRecent =
      recent.reduce((sum, s) => sum + s.summary.total, 0) / recent.length;

    const older = scanHistory.slice(-6, -3);
    const avgOlder =
      older.reduce((sum, s) => sum + s.summary.total, 0) /
      Math.max(older.length, 1);

    if (avgRecent < avgOlder * 0.8) return 'improving';
    if (avgRecent > avgOlder * 1.2) return 'declining';
    return 'stable';
  }

  /**
   * Get vulnerability by ID
   */
  getVulnerability(id: string): SecurityVulnerability | undefined {
    return this.vulnerabilities.get(id);
  }

  /**
   * Get scan result by ID
   */
  getScanResult(id: string): SecurityScanResult | undefined {
    return this.scanResults.get(id);
  }

  /**
   * Get penetration test result by ID
   */
  getPenTestResult(id: string): PenetrationTestResult | undefined {
    return this.penTestResults.get(id);
  }

  /**
   * Get all open vulnerabilities
   */
  getOpenVulnerabilities(): SecurityVulnerability[] {
    return Array.from(this.vulnerabilities.values()).filter(
      v => v.status === 'open'
    );
  }
}

// Export singleton instance
export const vulnerabilityManagementService =
  new VulnerabilityManagementService();
